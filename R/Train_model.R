#' Trains model
#'
#' @description
#' `Train_model()` trains a multinomial logistic regression model with a LASSO penalty, where the outcome categories are the current CRAN Task Views
#'  and an additional "None" category.
#'
#' @details
#' The `Train_model()` function, relies on the four internal functions [get_data()], [get_NLP()], [get_create_features()] and [get_CRAN_logs()].
#' These four internal functions are run within each other in this order e.g. `Train_model()` initiates with running [get_CRAN_logs()] which initiates with [get_create_features()].
#' Hence the entire pipeline begins with [get_data()].
#'
#' The `Train_model()` function itself, after running [get_CRAN_logs()], carries out the model training using the response matrix and feature matrix that were constructed with the four internal
#' functions mentioned above.
#'
#' @inheritParams get_NLP
#'
#' @return Returns
#'\itemize{
#'   \item `predicted_probs_for_suggestions` - [data.frame] where each row is the predicted probability vector for each CRAN package that is not assigned Task View
#'         that does not meet monthly download threshold. `predicted_probs_for_suggestions` is created using the [predict()] function and the `model` object.
#'   \item `model` - Model object
#'   \item `model` accuracy - A percentage value which says how accurate the model is on a test set.
#' }
#' @export
#'

Train_model = function(TEST = FALSE,
                       limiting_n_observations = 100,
                       get_input_stored = FALSE,
                       get_input_path = "tests/testthat/fixtures/get_CRAN_logs_output/get_CRAN_logs_output.rds",
                       save_output = FALSE,
                       save_path = "OUTPUT/"){


  # Objects needed to run generated by previous script:
  # tvdb
  # no_tsk_pckgs_meet_threshold
  # final_package_names
  # features
  # response_matrix
  # all_CRAN_pks

  # Objects Outputted:
  # predicted_probs_for_suggestions



#### ----------------------------------------------------------------------------------------------- ####

  if(get_input_stored){
    get_CRAN_logs_output = readRDS(get_input_path)

    }else{

    # Get required objects from CTVsuggest:::get_CRAN_logs()
    get_CRAN_logs_output = CTVsuggestTrain:::get_CRAN_logs(TEST = TEST, limiting_n_observations = limiting_n_observations)

  }

#### ----------------------------------------------------------------------------------------------- ####


#### ----------------------------------------------------------------------------------------------- ####

  # Loading vector of packages with no Task View assignment that do not meet threshold
  no_tsk_pckgs_meet_threshold = base::intersect(get_CRAN_logs_output$no_tsk_pckgs_meet_threshold, get_CRAN_logs_output$final_package_names)
  no_tsk_pckgs_meet_threshold = unique(no_tsk_pckgs_meet_threshold)

  # The training and testing sets are made up of the packages that either have:
  # no Task View but meet download threshold
  # (response_matrix[no_tsk_pckgs_meet_threshold,])
  # or has an assigned Task View
  # (response_matrix[response_matrix[,"none"] == 0,])

  # Combining the two sets
  labelled_data_res = (rbind(get_CRAN_logs_output$response_matrix[get_CRAN_logs_output$response_matrix[,"none"] == 0,],    get_CRAN_logs_output$response_matrix[no_tsk_pckgs_meet_threshold,]))
  labelled_data_features = get_CRAN_logs_output$features[rownames(labelled_data_res),]


  # Splitting the response matrix and feature matrix with 80:20 ratio
  set.seed(3)
  split1<- sample(c(rep(0, 0.8 * nrow(labelled_data_res)), rep(1, 0.2 * nrow(labelled_data_res))))
  # table(split1)

  train_res = labelled_data_res[split1 == 0,]
  train_features = labelled_data_features[split1 == 0,]

  test_res = labelled_data_res[split1 == 1,]
  test_feature = labelled_data_features[split1 == 1,]

#### ----------------------------------------------------------------------------------------------- ####


#### ----------------------------------------------------------------------------------------------- ####
  ## LASSO ##

  # removing row that has missing features
  # train_res = train_res[!apply(as.matrix(train_features),1, function(x){any(is.na(x))}),]
  # train_features = train_features[!apply(as.matrix(train_features),1, function(x){any(is.na(x))}),]

  train_res = as.matrix(train_res)
  train_features = as.matrix(train_features)

  train_sparse <- Matrix::sparse.model.matrix(~., as.data.frame(train_features))
  train_res_sparse <- Matrix::sparse.model.matrix(~0 + ., as.data.frame(train_res))

  message("Training model")
  set.seed(3)
  model_multinom_cv = glmnet::cv.glmnet(x = train_sparse,  y = train_res, family = "multinomial", alpha = 1, trace.it = 1, nlambda = 200)
#### ----------------------------------------------------------------------------------------------- ####



#### ----------------------------------------------------------------------------------------------- ####
#### Accuracy ####

model = model_multinom_cv
predict_class = predict(model, newx = cbind(rep(1, nrow(test_feature)),as.matrix(test_feature)), s = "lambda.min",  type = "class")
# Getting accuracy of model after applying lasso with min Lambda
predict_class = factor(predict_class[,1], levels = c(RWsearch::tvdb_vec(get_CRAN_logs_output$tvdb), "none"))



model_accuracy = mean(test_res[cbind(1:nrow(test_res), predict_class)], na.rm = T)
model_accuracy = 100*model_accuracy

# apply(test_res[which(test_res[cbind(1:nrow(test_res), predict_class)] == 0),],2,sum)
#### ----------------------------------------------------------------------------------------------- ####


#### ----------------------------------------------------------------------------------------------- ####
##### Predicted probabilities from model ######
# Vector of packages that are not assigned a Task View that do not meet threshold
# Will then get classification probabilities for these packages using the trained model
pkgs_for_suggestions = get_CRAN_logs_output$final_package_names[!(get_CRAN_logs_output$final_package_names %in% get_CRAN_logs_output$no_tsk_pckgs_meet_threshold) & (get_CRAN_logs_output$response_matrix[,"none"] == 1)]
pkgs_for_suggestions_features = get_CRAN_logs_output$features[pkgs_for_suggestions,]

# If there are packages that belong to `pkgs_for_suggestions` but are not in the rownames of features then creates some NA rows. Delete these here:
pkgs_for_suggestions_features = pkgs_for_suggestions_features[!apply(as.matrix(pkgs_for_suggestions_features),1, function(x){any(is.na(x))}),]



predicted_probs_for_suggestions = predict(model_multinom_cv, newx = cbind(rep(1, nrow(pkgs_for_suggestions_features)),as.matrix(pkgs_for_suggestions_features)), s = "lambda.min", type = "response")
predicted_probs_for_suggestions = data.frame(predicted_probs_for_suggestions)
colnames(predicted_probs_for_suggestions) = gsub(x = colnames(predicted_probs_for_suggestions), pattern = "\\.1", "")
predicted_probs_for_suggestions$Packages = row.names(predicted_probs_for_suggestions)
#### ----------------------------------------------------------------------------------------------- ####

if(save_output){

  if(!dir.exists(file.path(save_path))){
    dir.create(file.path(save_path))
  }

attr(model, "date") = Sys.Date()
attr(predicted_probs_for_suggestions, "date") = Sys.Date()
attr(model_accuracy, "date") = Sys.Date()


save(model, file = file.path(save_path, "model.rda"))
save(predicted_probs_for_suggestions, file = file.path(save_path, "predicted_probs_for_suggestions.rda"))
save(model_accuracy, file = file.path(save_path, "model_accuracy.rda"))
message("Objects: model, predicted_probs_for_suggestions and model_accuracy have been saved to the path ", file.path(save_path))


}else{
  # If save = FALSE. Then objects are assigned to Global Environment
    return_list = list("model" = model,
                    "predicted_probs_for_suggestions" = predicted_probs_for_suggestions,
                    "model_accuracy" = model_accuracy)

    list2env(return_list, envir = .GlobalEnv)
  }

}

